pipeline {
    agent any

    options {
        disableConcurrentBuilds()
        timeout(time: 12, unit: 'HOURS')
        timestamps()
        ansiColor('xterm')
    }

    parameters {
        string(name: 'DEVICE', defaultValue: '', description: 'Device Codename')
        string(name: 'LOCAL_MANIFEST_URL', defaultValue: '', description: 'Manifest XML URL')
        choice(name: 'BUILD_TYPE', choices: ['userdebug', 'user', 'eng'], description: 'Build Type')
        choice(name: 'BUILD_VARIANT', choices: ['Test', 'Release'], description: 'Build Variant')
        choice(name: 'GAPPS_VARIANT', choices: ['default', 'false', 'core', 'basic', 'true'], description: 'GApps Variant')
        string(name: 'CLEAN_BUILD', defaultValue: 'false', description: 'Clean Build')
        string(name: 'DIRTY_BUILD', defaultValue: 'false', description: 'Dirty Build')
        string(name: 'DISABLE_FSGEN', defaultValue: 'false', description: 'Disable FSGen')
        
        // Metadata from Bot
        string(name: 'REQUESTER', defaultValue: 'Jenkins', description: 'Requester Name')
        string(name: 'TG_USER_ID', defaultValue: '', description: 'Telegram User ID')
        string(name: 'TG_MSG_ID', defaultValue: '', description: 'Telegram Message ID to Edit')
    }

    environment {
        // --- CREDENTIALS (Set in Jenkins) ---
        TELEGRAM_TOKEN = credentials('telegram-token')
        TELEGRAM_CHAT_ID = credentials('telegram-chat-id')
        // ID Topic untuk Notifikasi Umum, Log Error, dan JSON OTA
        TELEGRAM_TOPIC_ID = '0'        // Default Topic
        TELEGRAM_LOG_TOPIC_ID = '123'  // Ganti dengan ID Topic Log
        TELEGRAM_OTA_TOPIC_ID = '456'  // Ganti dengan ID Topic OTA

        // --- GLOBAL VARS ---
        DEVICE = "${params.DEVICE}"
        BUILD_TYPE = "${params.BUILD_TYPE}"
        BUILD_VARIANT = "${params.BUILD_VARIANT}"
        GAPPS_VARIANT = "${params.GAPPS_VARIANT}"
        CLEAN_BUILD = "${params.CLEAN_BUILD}"
        DIRTY_BUILD = "${params.DIRTY_BUILD}"
        DISABLE_FSGEN = "${params.DISABLE_FSGEN}"
        REQUESTER = "${params.REQUESTER}"
        TG_MSG_ID = "${params.TG_MSG_ID}"
        TG_USER_ID = "${params.TG_USER_ID}"
        
        // Point to builder scripts (Assuming repo is checked out to workspace) 
        ROOTDIR = "${WORKSPACE}" 
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Mapping Display
                    def gMap = ['true':'Full', 'false':'Vanilla', 'core':'Core', 'basic':'Basic', 'default':'Default']
                    env.GAPPS_DISPLAY = gMap.get(params.GAPPS_VARIANT, params.GAPPS_VARIANT)
                    env.FSGEN_STATUS = (params.DISABLE_FSGEN == 'true') ? "Disabled" : "Enabled"
                    env.DIRTY_STATUS = (params.DIRTY_BUILD == 'true') ? "Yes" : "No"
                    env.CLEAN_STATUS = (params.CLEAN_BUILD == 'true') ? "Yes" : "No"
                    
                    if (params.TG_USER_ID != '') {
                        env.USER_TAG = "[${params.REQUESTER}](tg://user?id=${params.TG_USER_ID})"
                    } else {
                        env.USER_TAG = "`${params.REQUESTER}`"
                    }
                }
                sh 'chmod +x builder/*.sh'
            }
        }

        stage('Quota Check') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-pat', passwordVariable: 'GH_PASS', usernameVariable: 'GH_USER')]) {
                        sh '''
                            git config --global user.email "jenkins@bot.com"
                            git config --global user.name "Jenkins Bot"
                            
                            # Pull latest quota
                            git pull origin main || true

                            COUNTER_FILE=".github/workflow_counter.json"
                            TODAY=$(date +%Y-%m-%d)
                            USER_NAME="${REQUESTER}"
                            LIMIT=5
                            
                            if [ ! -f "$COUNTER_FILE" ]; then echo "{}" > "$COUNTER_FILE"; fi

                            # Check usage
                            USAGE=$(jq -r --arg user "$USER_NAME" --arg date "$TODAY" 'if .[$user][$date] then .[$user][$date] else 0 end' "$COUNTER_FILE")
                            
                            # Basic Admin Check (Hardcoded or fetch via API)
                            # Assuming standard user for now.
                            
                            if [ "$USAGE" -ge "$LIMIT" ]; then
                                echo "‚ùå Limit Reached ($USAGE/$LIMIT)"
                                # Send Reject Message
                                MSG="üö´ *Build Rejected*\nUser: ${USER_TAG}\nReason: Daily Limit Reached."
                                curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/editMessageText" \
                                    -d chat_id="${TELEGRAM_CHAT_ID}" \
                                    -d message_id="${TG_MSG_ID}" \
                                    -d parse_mode="Markdown" \
                                    --data-urlencode "text=$MSG" || true
                                exit 1
                            fi
                            
                            # Update Quota
                            NEW_VAL=$((USAGE + 1))
                            jq --arg user "$USER_NAME" --arg date "$TODAY" --argjson v "$NEW_VAL" \
                                'if .[$user] then .[$user][$date] = $v else .[$user] = {($date): $v} end' "$COUNTER_FILE" > tmp.json && mv tmp.json "$COUNTER_FILE"
                            
                            # Push
                            git add "$COUNTER_FILE"
                            git commit -m "Quota update: $USER_NAME ($NEW_VAL)" || true
                            git push https://${GH_USER}:${GH_PASS}@github.com/${GH_USER}/AfterlifeOS-Builder.git HEAD:main || echo "Push failed, continuing build..."
                        '''
                    }
                }
            }
        }

        stage('Sync Source') {
            steps {
                script {
                    // Update Telegram: Syncing
                    def syncMsg = """
                    üîÑ *Syncing Source...*
                    *Device:* `${DEVICE}`
                    *Type:* `${BUILD_TYPE}`
                    *Variant:* `${BUILD_VARIANT}`
                    *GApps:* `${GAPPS_DISPLAY}`
                    *FSGen:* `${FSGEN_STATUS}`
                    *Dirty:* `${DIRTY_STATUS}`
                    *Clean:* `${CLEAN_STATUS}`
                    *User:* ${USER_TAG}

                    Please wait...
                    *Link:* [View Console](${env.BUILD_URL}console)"""
                    
                    writeFile file: 'msg.txt', text: syncMsg
                    sh '''
                        if [ ! -z "$TG_MSG_ID" ]; then
                            TEXT=$(cat msg.txt)
                            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/editMessageText" \
                                -d chat_id="${TELEGRAM_CHAT_ID}" \
                                -d message_id="${TG_MSG_ID}" \
                                -d parse_mode="Markdown" \
                                --data-urlencode "text=$TEXT" || true
                        fi
                    '''
                    
                    // Run Sync
                    sh 'bash builder/sync.sh'
                }
            }
        }

        stage('Patch FSGen') {
            when { expression { params.DISABLE_FSGEN == 'true' } }
            steps {
                script {
                    sh '''
                        source builder/config.sh
                        TARGET="$ROOTDIR/build/soong/fsgen/Android.bp"
                        if [ -f "$TARGET" ]; then
                            cp "$TARGET" "${WORKSPACE}/Android.bp.bak"
                            sed -i '/name: "soong_filesystem_creator",/a \    enabled: false,' "$TARGET"
                        fi
                    '''
                }
            }
        }

        stage('Build ROM') {
            steps {
                script {
                    // build.sh handles its own notifications (Start, Progress, Success, Fail)
                    // We just need to ensure it has the env vars
                    sh 'bash builder/build.sh'
                }
            }
        }

        stage('Upload Artifacts') {
            steps {
                sh 'bash builder/smart_upload.sh'
            }
        }
    }

    post {
        always {
            script {
                // Restore FSGen
                if (params.DISABLE_FSGEN == 'true') {
                    sh '''
                        source builder/config.sh
                        TARGET="$ROOTDIR/build/soong/fsgen/Android.bp"
                        BACKUP="${WORKSPACE}/Android.bp.bak"
                        if [ -f "$BACKUP" ]; then
                            cp -f "$BACKUP" "$TARGET"
                            rm "$BACKUP"
                        fi
                    '''
                }
                sh 'rm -f msg.txt'
            }
        }
        
        failure {
            script {
                // If build.sh failed properly, it sends a failure log.
                // But if the Pipeline fails (e.g. Sync error, Script error), we need to notify.
                // We check if "build.sh" was the cause or something else.
                
                def failMsg = """
‚ùå *Pipeline FAILED*
*Device:* `${DEVICE}`
*User:* ${USER_TAG}
*Link:* [View Console](${env.BUILD_URL}console)"""
                
                writeFile file: 'fail.txt', text: failMsg
                sh '''
                    # Check if build.sh handled it (check for some marker file or similar, optional)
                    # For now, we aggressively update the status to Fail.
                    
                    if [ ! -z "$TG_MSG_ID" ]; then
                        TEXT=$(cat fail.txt)
                        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/editMessageText" \
                            -d chat_id="${TELEGRAM_CHAT_ID}" \
                            -d message_id="${TG_MSG_ID}" \
                            -d parse_mode="Markdown" \
                            --data-urlencode "text=$TEXT" || true
                    fi
                    
                    # Upload Console Log snippet to Log Topic
                    tail -n 100 log > snippet.log 2>/dev/null || echo "Log unavailable" > snippet.log
                    curl -F "chat_id=${TELEGRAM_CHAT_ID}" \
                         -F "message_thread_id=${TELEGRAM_LOG_TOPIC_ID}" \
                         -F "document=@snippet.log" \
                         -F "caption=Pipeline Failure Log" \
                         "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendDocument" || true
                '''
            }
        }

        aborted {
            script {
                 def cancelMsg = """
‚ö†Ô∏è *Build CANCELLED*
*Device:* `${DEVICE}`
*User:* ${USER_TAG}
*Link:* [View Console](${env.BUILD_URL}console)"""
                 
                 writeFile file: 'cancel.txt', text: cancelMsg
                 sh '''
                    if [ ! -z "$TG_MSG_ID" ]; then
                        TEXT=$(cat cancel.txt)
                        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/editMessageText" \
                            -d chat_id="${TELEGRAM_CHAT_ID}" \
                            -d message_id="${TG_MSG_ID}" \
                            -d parse_mode="Markdown" \
                            --data-urlencode "text=$TEXT" || true
                    fi
                 '''
            }
        }
    }
}